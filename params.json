{"name":"Clockmaker","tagline":"Flexible Javascript timers which can be paused and modified on-the-fly","body":"# Clockmaker\r\n\r\n[![Build Status](https://secure.travis-ci.org/hiddentao/clockmaker.png)](http://travis-ci.org/hiddentao/clockmaker)\r\n\r\nA flexible timer management system for Javascript.\r\n\r\nClockmaker is inspired by [Mozilla's MiniDaemon](https://developer.mozilla.org/en-US/docs/Web/API/window.setInterval#A_little_framework) and provides an alternative to the built-in `setTimeout` and `setInterval` functions. It is \r\nespecially useful when you are running multiple timers and wish to exercise \r\nbetter control over them.\r\n\r\nFeatures:\r\n\r\n* Stop and restart timers.\r\n* Change the timer delay in real-time.\r\n* Start and stop multiple timers in one go.\r\n* Robust error handling.\r\n* Uses method chaining for ease of use.\r\n* Works in node.js and in the browser.\r\n* Has no other dependencies.\r\n* Small: <1 KB minified and gzipped.\r\n\r\n## Installation\r\n\r\n### node.js\r\n\r\nInstall using [npm](http://npmjs.org/):\r\n\r\n    $ npm install clockmaker\r\n\r\n### Browser\r\n\r\nUse [bower](https://github.com/bower/bower):\r\n\r\n    $ bower install clockmaker\r\n\r\nOr add the following inside your HTML:\r\n\r\n```html\r\n<script type=\"text/javascript\" src=\"https://rawgithub.com/hiddentao/clockmaker/master/clockmaker.min.js\"></script>\r\n```\r\n\r\n## How to use\r\n\r\nThese examples are all running in node.js. At the top of each example assume \r\nwe have the following:\r\n\r\n```javascript\r\nvar Timer = require('clockmaker').Timer,\r\n    Timers = require('clockmaker').Timers;\r\n```\r\n\r\n\r\n\r\n### setTimeout\r\n\r\nThe basic `Timer` works in the same way as `setTimeout`:\r\n\r\n```javascript\r\nTimer(function() {\r\n  console.log('2 seconds done');\r\n}, 2000).start();\r\n```\r\n\r\nNotice how `start()` needs to be called to kick-off the timer. You can also \r\nexplicitly construct the `Timer` object:\r\n\r\n```javascript\r\nvar timer = new Timer(function() {\r\n  console.log('2 seconds done');\r\n}, 2000);\r\n\r\ntimer.start();\r\n```\r\n\r\nOnce a basic timer has ticked and invoked its handler it cannot be started again:\r\n\r\n```javascript\r\nvar timer = new Timer(function() {\r\n  console.log('2 seconds done');\r\n}, 2000);\r\n\r\ntimer.start();\r\ntimer.isStopped();  // false\r\n\r\n// ... some time later\r\n\r\ntimer.start();  \r\ntimer.isStopped();  // true\r\n```\r\n\r\n### setInterval\r\n\r\nWe simulate `setInterval` behaviour by setting `repeat: true` in the options.\r\n\r\n```javascript\r\nvar timer = new Timer(function() {\r\n  console.log('Another 2 seconds done');\r\n}, 2000, {\r\n  repeat: true\r\n});\r\n\r\ntimer.start();\r\n```\r\n\r\nLet's stop the timer after 10 ticks:\r\n\r\n```javascript\r\nvar count = 0;\r\n\r\nvar timer = new Timer(function() {\r\n  console.log('Another 2 seconds done');\r\n\r\n  count++;\r\n  if (10 === count) {\r\n    timer.stop();\r\n  }\r\n}, 2000, {\r\n  repeat: true\r\n});\r\n\r\ntimer.start();\r\n```\r\n\r\nWe can change the delay interval in real-time:\r\n\r\n```javascript\r\nvar delayMs = 1000;\r\n\r\nvar timer = new Timer(function() {\r\n  console.log('Next tick will take 1 second longer');\r\n\r\n  delayMs += 1000;\r\n  timer.setDelay(delayMs);\r\n}, delayMs, {\r\n  repeat: true\r\n});\r\n\r\ntimer.start();\r\n```\r\n\r\nLet's stop and restart the timer using a second timer:\r\n\r\n```javascript\r\nvar timer = new Timer(function() {\r\n  console.log('Another 2 seconds done');\r\n}, 2000, {\r\n  repeat: true\r\n});\r\n\r\ntimer.start();\r\n\r\n\r\n// This second timer which will stop/start the first timer every 5 seconds\r\nTimer(function() {\r\n  if (timer.isStopped()) {\r\n    timer.start();\r\n  } else {\r\n    timer.stop();\r\n  }\r\n}, 5000, {\r\n  repeat: true\r\n}).start();\r\n```\r\n\r\nA timer does not keep track of how much time has elapsed when it gets stopped. \r\nSo when it gets started again it resumes with the full time delay.\r\n\r\n\r\n### Asynchronous handlers\r\n\r\nThe timer waits for the handler to finish executing before scheduling the next \r\ntick. But what if our handler is asynchronous? we have to inform the timer of \r\nthis:\r\n\r\n```javascript\r\nvar timer = new Timer(function(cb) {\r\n  // ... do some stuff\r\n  cb();\r\n}, 2000, {\r\n  repeat: true,\r\n  async: true\r\n});\r\n\r\ntimer.start();\r\n```\r\n\r\nUntil our handler invokes the `cb()` callback (see above) the timer will not \r\nschedule the next tick. This allows us to decide whether we want to schedule \r\nthe next tick straight away or once we've done all our necessary work inside \r\nour handler.\r\n\r\n\r\n### This context\r\n\r\nThe `this` context for the handler function can be set:\r\n\r\n```javascript\r\nvar ctx = {\r\n  dummy: true\r\n};\r\n\r\nnew Timer(function() {\r\n  console.log(this.dummy);  // true\r\n}, 2000, {\r\n  this: ctx\r\n}).start();\r\n```\r\n\r\n\r\n### Synchronize to now\r\n\r\nSometimes we may want to reset a timer that's already running, i.e. stop and \r\nthen restart it without actually having to do so:\r\n\r\n```javascript\r\n/*\r\nIn this example the second timer keeps 'resetting' the first one every 100ms. \r\nThe net effect is that the first timer never actually completes a tick.\r\n */\r\nvar timer = new Timer(function() {\r\n  console.log('hell world');  // this never gets executed\r\n}, 2000);\r\n\r\ntimer.start();\r\n\r\nTimer(function() {\r\n  timer.synchronize();\r\n}, 100).start();\r\n```\r\n\r\n### Handling errors\r\n\r\nWe can pass in an `onError` handler to be informed of errors:\r\n\r\n```javascript\r\nnew Timer(function() {\r\n  throw new Error('A dummy error');\r\n}, 2000, {\r\n  onError: function(err) {\r\n    console.error(err);  // A dummy error\r\n  }\r\n}).start();\r\n```\r\n\r\nError handling works for asynchronous handlers too:\r\n\r\n```javascript\r\nnew Timer(function(cb) {\r\n  cb(new Error('A dummy error'));\r\n}, 2000, {\r\n  async: true,\r\n  onError: function(err) {\r\n    console.error(err);  // A dummy error\r\n  }\r\n}).start();\r\n```\r\n\r\n### Multiple timers\r\n\r\nWe can control multiple timers at a time by using the `Timers` interface.\r\n\r\n```javascript\r\nvar timers = new Timers();\r\n\r\nvar timer1 = timers.new(handlerFn, 2000, { repeat: true });\r\nvar timer2 = timers.new(aletFn, 1000);\r\nvar timer3 = ...\r\n\r\ntimer1.start(); // we can start them one a a time, or...\r\n\r\ntimers.start(); // ...start them all at once\r\n\r\n... // some time later\r\n\r\ntimers.stop();  // stop all timers\r\n```\r\n\r\n## noConflict\r\n\r\nIf you're using Clockmaker in a browser app and are not using an AMD or \r\nCommonJS module system then it will add two new items into the global scope:\r\n\r\n* `Timer`\r\n* `Timers`\r\n\r\nIf these clash with existing values in your global scope then you can use the \r\n`.noConflict()` method calls to restore your existing values:\r\n\r\n```javascript\r\n// assume we're running in browser global scope, i.e. window\r\n\r\nvar Timer = 'my timer class';\r\nvar Timers = 'my timers class';\r\n\r\n// ... load clockmaker ...\r\n\r\nconsole.log(Timer); // Function\r\nconsole.log(Timers); // Function\r\n\r\n// restore my definitions\r\n\r\nvar ClockmakerTimer = Timer.noConflict();\r\nvar ClockmakerTimers = Timers.noConflict();\r\n\r\nconsole.log(Timer); // 'my timer class'\r\nconsole.log(Timers); // 'my timers class'\r\n```\r\n\r\n\r\n## Building\r\n\r\nTo build the code:\r\n\r\n    $ npm install -g gulp\r\n    $ npm install\r\n    $ gulp build <-- this will build the code and run the tests\r\n\r\n\r\n## Contributing\r\n\r\nContributions are welcome! Please see CONTRIBUTING.md.\r\n\r\n\r\n## License\r\n\r\nMIT - see LICENSE.md","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}